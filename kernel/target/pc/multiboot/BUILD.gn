# Copyright 2018 The Fuchsia Authors
#
# Use of this source code is governed by a MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT

# The Multiboot trampoline gets its own toolchain to build x86-32 code.
multiboot_toolchain = get_label_info(":x64-multiboot", "label_no_toolchain")

if (current_toolchain == multiboot_toolchain) {
  # This is the top config for all code in the multiboot_toolchain.
  config("multiboot_config") {
    configs = [
      "$zx/kernel:standalone",
      "$zx/kernel:warnings",
    ]
    cflags = [
      "-m32",
      "-mregparm=3",
      "-fno-pic",
    ]
    asmflags = cflags
    ldflags = cflags
  }

  # We could make a Multiboot image meant to be loaded without ELF headers
  # and do `objcopy -O binary` here.  But there's no reason to, and having
  # an ELF binary to look at is nicer.  To remove the ELF headers instead,
  # the linker script would need to remove `+ SIZEOF_HEADERS` and then the
  # multiboot header would be first thing in the raw binary.  The toolchain
  # implicitly strips executables, so `multiboot.bin` is a lean, fully
  # stripped ELF/Multiboot image.
  executable("multiboot") {
    output_extension = "bin"
    metadata = {
      image_files = [ "$root_out_dir/$target_name.$output_extension" ]
      images = {
        name = "multiboot"
        path = rebase_path(image_files[0], root_build_dir)
      }
    }
    sources = [
      "multiboot-main.c",
      "multiboot-start.S",
      "paging.c",
      "trampoline.c",
      "util.c",
    ]
    deps = [
      "$zx/kernel/arch/x86/page_tables:headers",
      "$zx/kernel/platform/pc:headers",
      "$zx/system/ulib/zbi",
    ]
    ldflags = [
      "-T",
      "multiboot.ld",
    ]
    inputs = [
      "multiboot.ld",
    ]
  }
} else {
  # In any other toolchain, just redirect to the proper toolchain.
  group("multiboot") {
    public_deps = [
      ":multiboot($multiboot_toolchain)",
    ]
  }

  # Define the special toolchain itself only in the default toolchain.
  if (current_toolchain == default_tooclhain) {
    define_environment("multiboot") {
      cpu = "x64"
      os = "multiboot"
      configs += [ ":multiboot_config" ]
      globals = {
        is_kernel = true
      }
      targets = [ ":multiboot" ]
    }
  }
}
