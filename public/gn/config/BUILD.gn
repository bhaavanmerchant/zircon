# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

config("compiler") {
  if (defined(toolchain.version_string) && toolchain.version_string != "") {
    # Nothing uses this define, but its presence on compilation command
    # lines ensures that Ninja will rebuild things when a new compiler
    # version arrives.
    defines = [ "TOOLCHAIN_VERSION=${toolchain.version_string}" ]
  }

  cflags = [ "-fno-common" ]

  cflags += [ "--target=${toolchain.target}" ]

  if (!is_gcc) {
    cflags += [ "-fcolor-diagnostics" ]
    asmflags = cflags
    ldflags = cflags

    # The macOS linker does not support `--color-diagnostics`.
    if (current_os != "mac") {
      ldflags += [ "-Wl,--color-diagnostics" ]
    }
  }

  #configs = [ "$current_os:compiler" ]
}

config("relative_paths") {
  # Make builds independent of absolute file path.  The file names embedded
  # in debugging information will be expressed as relative to the build
  # directory, e.g. "../.." for an "out/subdir" under //.  This is
  # consistent with the file names in __FILE__ expansions (e.g. in
  # assertion messages), which the compiler doesn't provide a way to remap.
  # That way source file names in logging and symbolization can all be
  # treated the same way.  This won't go well if $root_build_dir is not a
  # subdirectory of //, but there isn't a better option to keep all source
  # file name references uniformly relative to a single root.
  absolute_path = rebase_path("//.")
  relative_path = rebase_path("//.", root_build_dir)

  # This makes sure that the DW_AT_comp_dir string (the current
  # directory while running the compiler, which is the basis for all
  # relative source file names in the DWARF info) is represented as
  # relative to //.
  cflags = [ "-fdebug-prefix-map=$absolute_path=$relative_path" ]
  if (!is_gcc) {
    # This makes sure that include directories in the toolchain are
    # represented as relative to the build directory (because that's how we
    # invoke the compiler), rather than absolute.  This can affect __FILE__
    # expansions (e.g. assertions in system headers).  We normally run a
    # compiler that's someplace within the source tree, so its absolute
    # installation path will have a prefix matching `absolute_path` and
    # hence be mapped to `relative_path` in the debugging information, so
    # this should actually be superfluous for purposes of the debugging
    # information.
    cflags += [ "-no-canonical-prefixes" ]
  }

  asmflags = cflags
  ldflags = cflags
}

config("linker_gc") {
  cflags = [
    "-fdata-sections",
    "-ffunction-sections",
  ]
  ldflags = cflags
  if (current_os == "mac") {
    ldflags += [ "-Wl,-dead_strip" ]
  } else {
    ldflags += [ "-Wl,--gc-sections" ]
  }
}

config("assert_level") {
  assert(assert_level >= 0)
  defines = [
    "LK_DEBUGLEVEL=$assert_level",
    "ZX_DEBUGLEVEL=$assert_level",
  ]
  if (assert_level == 0) {
    defines += [ "NDEBUG=1" ]
  }
}

config("opt_level") {
  if (opt_level == -1) {
    cflags = [ "-O0" ]
  } else {
    assert(opt_level >= 0)
    if (opt_level == 0) {
      if (is_gcc) {
        cflags = [ "-O0" ]
      } else {
        cflags = [ "-Og" ]
      }
    } else if (opt_level == 4) {
      if (is_gcc) {
        cflags = [ "-Os" ]
      } else {
        cflags = [ "-Oz" ]
      }
    } else {
      cflags = [ "-O$opt_level" ]
    }
  }
  if (opt_level > 0) {
    cflags += [ "-finline-functions" ]
    configs = [ ":linker_gc" ]
  }
  ldflags = cflags
}

config("symbol_level") {
  assert(symbol_level >= 0 && symbol_level <= 2)
  if (symbol_level == 0) {
    cflags = [ "-g0" ]
  } else if (symbol_level == 1) {
    cflags = [ "-gline-tables-only" ]
  } else if (symbol_level == 2) {
    cflags = [ "-g3" ]
  }
  asmflags = cflags
  ldflags = cflags
}
