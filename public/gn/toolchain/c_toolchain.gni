# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("ccache.gni")
import("clang.gni")
import("gcc.gni")
import("goma.gni")
import("toolchain.gni")

template("define_c_toolchain") {
  # Translate GN cpu/os to GNU config tuple.
  if (invoker.cpu == "arm64") {
    tc_cpu = "aarch64"
  } else if (invoker.cpu == "x64") {
    tc_cpu = "x86_64"
  } else {
    tc_cpu = invoker.cpu
  }
  tc_target = "${tc_cpu}-"
  if (invoker.os == "mac") {
    tc_target += "darwin"
  } else if (invoker.os == "win") {
    tc_target += "windows-msvc"
  } else {
    tc_target += invoker.os
  }

  # Cached and distributed wrappers just go on the front of compiler commands.
  compiler_prefix = ""
  if (defined(invoker.use_goma)) {
    use_goma = invoker.use_goma
  }
  if (use_goma) {
    compiler_prefix = "$goma_dir/gomacc "
  } else {
    if (defined(invoker.use_ccache)) {
      use_ccache = invoker.use_ccache
    }
    if (use_ccache) {
      compiler_prefix = "ccache "
    }
  }

  use_gcc = defined(invoker.gcc) && invoker.gcc
  use_strip = defined(invoker.strip) && invoker.strip != false

  # If either is supplied both must be supplied.
  if (defined(invoker.tool_dir) || defined(invoker.tool_prefix)) {
    tc = {
      tool_dir = invoker.tool_dir
      tool_prefix = invoker.tool_prefix
    }
  } else if (use_gcc) {
    if (defined(invoker.host) && invoker.host) {
      # Using host vanilla GCC, so this can't be cross-compiling.
      assert(invoker.cpu == host_cpu)
      assert(invoker.os == host_os)
      tc = {
        tool_dir = ""
        tool_prefix = ""
      }
    } else {
      tc = {
        tool_dir = gcc_tool_dir
        tool_prefix = "${invoker.cpu}-elf-"
        version_string = gcc_version_string
      }
    }
  } else {
    tc = {
      tool_dir = clang_tool_dir
      tool_prefix = "llvm-"
      version_string = clang_version_string
    }
  }

  if (use_gcc) {
    tc.cc = "${tc.tool_prefix}gcc"
    tc.cxx = "${tc.tool_prefix}g++"
  } else {
    tc.cc = "clang"
    tc.cxx = "clang++"
  }

  if (tc.tool_dir == "") {
    dir_prefix = ""
  } else {
    dir_prefix = rebase_path(tc.tool_dir, root_build_dir) + "/"
  }

  cc = "$compiler_prefix$dir_prefix${tc.cc}"
  cxx = "$compiler_prefix$dir_prefix${tc.cxx}"
  ld = cxx
  ar = "$dir_prefix${tc.tool_prefix}ar"

  _compile_common = {
    outputs = [
      "{{source_out_dir}}/{{target_output_name}}.{{source_file_part}}.o",
    ]
    depfile = "{{output}}.d"
    depsformat = "gcc"
    switches = "-MD -MF $depfile -o {{output}} {{defines}} {{include_dirs}}"
  }

  _link_common = {
    lib_switch = "-l"
    lib_dir_switch = "-L"
    default_output_dir = "{{target_out_dir}}"
    outfile = "{{output_dir}}/{{target_output_name}}{{output_extension}}"
    runtime_outputs = [ outfile ]
    outputs = runtime_outputs
    if (use_strip) {
      unstripped_outfile = "${outfile}.debug"
      outputs += [ unstripped_outfile ]
      strip_command = " && "
      if (invoker.strip == true) {
        strip_command +=
            "$dir_prefix${tc.tool_prefix}strip -o $outfile $unstripped_outfile"
      } else {
        strip_command += "$dir_prefix${tc.tool_prefix}objcopy ${invoker.strip} $unstripped_outfile $outfile"
      }
    } else {
      unstripped_outfile = outfile
      strip_command = ""
    }
    if (invoker.os != "mac" && invoker.os != "win") {  # All others are ELF.
      readelf = "$dir_prefix${tc.tool_prefix}readelf"
      id_dir = "build-id"
      strip_command += " && notes=\$(\"$readelf\" -n $unstripped_outfile) && id=\"\${notes##*Build ID: }\" && nl=\$(echo; echo '*') && id=\"\${id%%\$nl}\" && { test -z \"\$id\" || { mkdir -p \"$id_dir/\${id:0:2}\" && ln -f $unstripped_outfile \"$id_dir/\${id:0:2}/\${id:2}\" ; } ; }"
    }
    rspfile = "${outfile}.rsp"
    switches = "-o $unstripped_outfile {{ldflags}}"
    if (invoker.os == "mac") {
      rspfile_content = "{{inputs_newline}}"
      link_inputs = "-Wl,-filelist,$rspfile"
      link_libs = "{{libs}} {{solibs}}"
    } else {
      rspfile_content = "{{inputs}}"
      link_inputs = "@'$rspfile'"
      if (invoker.os == "win") {
        link_libs = "{{libs}} {{solibs}}"
      } else {
        link_libs = "-Wl,--start-group {{libs}} -Wl,--end-group {{solibs}}"
        mapfile = "${outfile}.map"
        outputs += [ mapfile ]
        switches += " -Wl,-Map,$mapfile"
      }
    }
  }

  define_toolchain(target_name) {
    propagates_configs = true

    tools = [
      {
        name = "asm"
        description = "ASM {{output}}"
        forward_variables_from(_compile_common, "*")
        command = "$cc $switches {{asmflags}} -c {{source}}"
      },

      {
        name = "cc"
        description = "CC {{output}}"
        forward_variables_from(_compile_common, "*")
        command = "$cc $switches {{cflags}} {{cflags_c}} -c {{source}}"
      },

      {
        name = "cxx"
        description = "CXX {{output}}"
        forward_variables_from(_compile_common, "*")
        command = "$cxx $switches {{cflags}} {{cflags_cc}} -c {{source}}"
      },

      {
        name = "objc"
        description = "OBJC {{output}}"
        forward_variables_from(_compile_common, "*")
        command = "$cc $switches {{cflags}} {{cflags_c}} {{cflags_objc}} -c {{source}}"
      },

      {
        name = "objcxx"
        description = "OBJCXX {{output}}"
        forward_variables_from(_compile_common, "*")
        command = "$cxx $switches {{cflags}} {{cflags_cc}} {{cflags_objcc}} -c {{source}}"
      },

      {
        name = "alink"
        description = "AR {{output}}"
        rspfile = "{{output}}.rsp"
        command =
            "rm -f {{output}} && $ar {{arflags}} cqsD {{output}} '@$rspfile'"
        rspfile_content = "{{inputs}}"
        default_output_dir = "{{target_out_dir}}"
        default_output_extension = ".a"
        output_prefix = "lib"
        outputs = [
          "{{output_dir}}/{{target_output_name}}{{output_extension}}",
        ]
      },

      {
        forward_variables_from(_link_common, "*")
        name = "link"
        description = "LINK $outfile"

        command = "$ld $switches $link_inputs $link_libs$strip_command"
      },
    ]

    if (defined(invoker.shlib) && invoker.shlib) {
      # We don't support building shared libraries for host tools.
      assert(invoker.os == "fuchsia",
             "shared library creation not supported for ${invoker.os}")

      solink_common = {
        forward_variables_from(_link_common, "*")
        depend_output = outfile
        link_output = unstripped_outfile
      }

      tools += [
        {
          forward_variables_from(solink_common, "*")

          name = "solink"
          description = "LINK_SHLIB $outfile"

          output_prefix = "lib"
          default_output_extension = ".so"

          # Put the automatic -soname first so that ldflags can override it.
          soname = "{{target_output_name}}{{output_extension}}"
          switches = "-shared -Wl,-soname,$soname $switches"

          command = "$ld $switches $link_inputs $link_libs$strip_command"

          # TODO: abi stubs
        },

        {
          forward_variables_from(solink_common, "*")

          name = "solink_module"
          description = "LINK_MODULE $outfile"

          default_output_extension = ".so"

          switches = "-shared $switches"
          command = "$ld $switches $link_inputs $link_libs$strip_command"
        },
      ]
    }

    forward_variables_from(invoker, [ "deps" ])

    toolchain_args = {
      current_cpu = invoker.cpu
      current_os = invoker.os

      if (defined(invoker.toolchain_args)) {
        forward_variables_from(invoker.toolchain_args,
                               "*",
                               [
                                 "current_cpu",
                                 "current_os",
                                 "toolchain",
                               ])
      }

      # This shadows the global and so has to be cleared first.
      toolchain = {
      }
      toolchain = {
        name = target_name
        label = get_label_info(":$target_name", "label_no_toolchain")

        # These are provided by BUILDCONFIG.gn so they are expected in
        # every toolchain.
        globals = {
        }
        public_deps = []

        # This gets `tool_dir` et al as expected by c_utils.gni (set above).
        forward_variables_from(tc, "*")
        cpu = tc_cpu
        target_tuple = tc_target

        if (invoker.os == "win") {
          executable_extension = "exe"
        } else {
          executable_extension = ""
        }

        if (defined(invoker.toolchain_vars)) {
          forward_variables_from(invoker.toolchain_vars, "*")
        }
      }
    }
  }
}
